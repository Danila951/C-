#include <iostream>
#include <cmath>

using namespace std;

double firstNorm(double  A[3][3],  int n, int m)
{
    int i, j;
    double sum = 0, subSum;
    for (i = 0; i < n; i++) {
        subSum = 0;
        for (j = 0; j < m; j++) {
            subSum += abs(A[i][j]);
        }
        if(subSum > sum) {
            sum = subSum;
        }
    }
    return sum;
}

double secondNorm(double  A[3][3], int n, int m)
{
    int i, j;
    double sum = 0, subSum;
    for (j = 0; j < n; j++) {
        subSum = 0;
        for (i = 0; i < m; i++) {
            subSum += abs(A[i][j]);
        }
        if(subSum > sum) {
            sum = subSum;
        }
    }
    return sum;
}

double thirdNorm(double A[3][3], int n, int m)
{
    int i, j;
    double sum = 0;
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            sum += (A[i][j] * A[i][j]);
        }
    }
    sum = sqrt(sum);
    return sum;
}

double okr(double X, double eps)
{
    int i = 0;
    while (eps != 1) {
        i++;
        eps *= 10;
    }
    int okr = pow(double(10), i);
    X = int(X * okr + 0.5) / double(okr);
    return X;
}


double iterat(double A[3][3], double B[3], int N, double eps)
{
    double q;
    q = min(min(firstNorm(A,N,N),secondNorm(A,N,N)),thirdNorm(A,N,N));
    if (q < 1) {
        int k = 0;
        int i, j;
        double X[3]={0, 0, 0};
        double Y[3];

        do {
            k++;
            // Решаем систему методом Зейделя.
                    Y[0] = X[0];
                    X[0] = B[0] + + A[0][0]*X[0] + A[0][1]*X[1] + A[0][2]*X[2];
                    
                    Y[1] = X[1];
                    X[1] = B[1] + A[1][0]*X[0] + A[1][1]*X[1] + A[1][2]*X[2];
                    
                    Y[2] = X[2];
                    X[2] = B[2] + A[2][0]*X[0] + A[2][1]*X[1] + A[2][2]*X[2];
                    
               

        } while ((q/(1-q))*fabs(Y[0]-X[0])>eps or (q/(1-q))*fabs(Y[1]-X[1])>eps or (q/(1-q))*fabs(Y[2]-X[2])>eps);

            cout << endl;
            cout << "Решение системы методом Зейделя:" << endl;
            for (i = 0; i < N; i++) {
                cout << "X" << i << " = " << okr(X[i],eps) << endl;
            }
            cout << "Число итераций: " << k << endl;
            cout << "Первая норма матрицы A: " << firstNorm(A,N,N) << endl;
            cout << "Вторая норма матрицы A: " << secondNorm(A,N,N) << endl;
            cout << "Третья норма матрицы A: " << thirdNorm(A,N,N) << endl;


    } else {
        cout << "Условие сходимости по евклидовой метрике не выполняется!" << endl;
    }

    return 0;
}


double pr_iterat(double A[3][3], double B[3], int N, double eps)
{
    double q;
    q = min(min(firstNorm(A,N,N),secondNorm(A,N,N)),thirdNorm(A,N,N));
    if (q < 1) {
        int k = 0;
        int i, j;
        double X[3]={0, 0, 0};
        double Y[3]={0, 0, 0};

        do {
            k++;
            // Решаем систему методом простых итераций.
                    X[0] = Y[0];
                    X[1] = Y[1];
                    X[2] = Y[2];
                    Y[0] = B[0] + A[0][0]*X[0] + A[0][1]*X[1] + A[0][2]*X[2];
                    Y[1] = B[1] + A[1][0]*X[0] + A[1][1]*X[1] + A[1][2]*X[2];
                    Y[2] = B[2] + A[2][0]*X[0] + A[2][1]*X[1] + A[2][2]*X[2];

        } while ((q/(1-q))*fabs(Y[0]-X[0])>eps or (q/(1-q))*fabs(Y[1]-X[1])>eps or (q/(1-q))*fabs(Y[2]-X[2])>eps);

            cout << endl;
            cout << "Решение системы методом простых итераций:" << endl;
            for (i = 0; i < N; i++) {
                cout << "X" << i << " = " << okr(X[i],eps) << endl;
            }
            cout << "Число итераций: " << k << endl;
            cout << "Первая норма матрицы A: " << firstNorm(A,N,N) << endl;
            cout << "Вторая норма матрицы A: " << secondNorm(A,N,N) << endl;
            cout << "Третья норма матрицы A: " << thirdNorm(A,N,N) << endl;


    } else {
        cout << "Условие сходимости по евклидовой метрике не выполняется!" << endl;
    }

    return 0;
}




int main()
{
    setlocale(LC_ALL, "Russian");

    double eps;
    int N=3, i, j;
    double A[3][3] = {
        {1.5, 2.3, -3.7},
        {1.2, 7.3, -2.3},
        {2.8, 3.4, 5.8},
    };
    double B[3] = {4.5, 5.6, -3.2};
    cout << "Введите точность вычислений: ";
    cin >> eps;
    
    for(int i = 0; i < N; i++) //Эквивалентные преобразования
    {
        A[0][i]=A[0][i] + A[2][i];
        A[0][i]=A[0][i] - A[1][i];
        A[2][i]=A[2][i] - A[1][i];
        
    }
    B[0] = B[0] + B[2];
    B[0] = B[0] - B[1];
    B[2] = B[2] - B[1];
    
    for (i = 0; i < N; i++) {
        A[i][i] -=10;
        for (j = 0; j < N; j++) {
            if(A[i][j]!=0) {
                A[i][j] = -A[i][j]/10;
            }
            
        }
        B[i] = B[i]/10;
    }

    cout << "\nВаша матрица А:" << endl;
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            cout << A[i][j] << " ";
        }
        cout << B[i] <<endl;
    }
    iterat(A,B,N,eps);
    pr_iterat(A,B,N,eps);
    return 0;
}

